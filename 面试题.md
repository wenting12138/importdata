### 面试题:

#### 1.并发编程:

##### 		 	       1.1 并发和并行的区别

  						并发(concurrent): 多个线程去访问同一个语言

  						并行: 各种事情并行去做

##### 			        1.2 volatile(单例模式)

​						是java虚拟机提供的轻量级的同步机制

```java
                private static volatile SingletonDemo singletonDemo;
                    private SingletonDemo(){}
                    public static SingletonDemo getInstance(){
                        if (singletonDemo == null) {
                            synchronized (SingletonDemo.class){
                                if (singletonDemo == null) {
                                    return singletonDemo = new SingletonDemo();
                                }
                            }
                        }
                        return singletonDemo;
                    }

```



​							保证可见性:  在主内存里的变量被更改后,其他线程立刻就会知道

​                            不能保证原子性(atomic):  	

​							禁止指令重排:  

​									计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排

​									源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排-> 最终执行的指令						 

​				jmm (java 0memory model)  java 内存模型: 可见性, 有序性, 原子性

​						是一种java规范

​						1. 线程解锁之前, 必须把共享内存刷回到主内存

​						2. 线程加锁之前,必须读取主内存的最新值到自己的工作内存中

​                        3. 加锁解锁是同一把锁

​				原子性:  不可分割,完整性,也即某个线程正在做某个具体业务时,中间不可被加塞或者被分隔,需要整体完整

##### 				        1.3 CAS(AtomicInteger):

​								Unsafe类: 使用了cpu指令原语的方式实现了CAS,指令原语具有原子性

```java
                public final long getAndAddLong(Object var1, long var2, long var4) {
                    					  // 执行这个方法的对象   对象的内存偏移量(地址)   要增加的数
                        long var6;
                        do {
                            // 首先通过对象和地址获取主内存的数据
                            var6 = this.getLongVolatile(var1, var2);
                            // 通过比较主内存的数据和 得到快照的数据进行比较, 如果相等, 就执行 + 操作
                        } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));

                        return var6;
                    }												
```

​									1.CAS缺点: 

​													1.1 循环时间长的话,cpu 开销会很大

​													1.2  只能保证一个共享变量的原子性

​							                         1.3  ABA问题:

​																假如主内存中有一个共享变量A, 线程t1首先从主存中copyA到自己的工作内存,然后t2线程抢到cpu的执行权,cpoyA到自己的

​																	工作内存,把A改为B,再刷会主内存,再获取B,改为A,刷回主内存,此时t1拿到执行权,根据CAS比较并交换,执行完毕, t1线程并没有

​																	 发现A变量的改变,

​																解决ABA问题:

​																			1.3.1:  使用AtomicReference

​																			1.3.2:  使用AtomicStampedRefenrence , 时间戳, 与乐观锁的机制类似   

​																								都会判断从主存中拿到的数据的版本是否和之前从主存中copy的数据版本是否一致

##### 			  	      1.4 非安全集合:			

​							1.ArrayList

​										1.1 可用使用Vector

​										1.2 可用使用Collections.synchronizedList();

​										1.3 可以使用CopyAndWriteArrayList

​							2.Set:      CopyAndWriteHashSet

​							3.Map:  

​											ConcurrentHashMap

#####                        1.5 锁:

​						1.公平锁:  在并发环境下,每个线程在获取锁时会先查看此锁维护的等待队列,如果为空,或者当前线程是等待队列的第一个,就占有锁,

​												否则就加入等待队列中,会按照先进先出的原则取到自己

​						2.非公平锁:  会直接获取锁,如果尝试失败,就会采取类似公平锁的机制

​						3.可重入锁:  指的是同一线程外层方法获取锁之后,即使内层递归函数有锁,仍然可以获取该锁的代码

​												在同一线程在外层方法获取锁的时候,在进入内层方法会自动获取锁

```java
                    Test test = new Test();
                            new Thread(() -> {
                                try {
                                    test.sendSMS();
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }, "t1").start();
                            new Thread(() -> {
                                try {
                                    test.sendSMS();
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }, "t2").start();

                        }
                        public synchronized void sendSMS() throws Exception{
                            System.out.println(Thread.currentThread().getName() + "\t invoked sendSMS");
                            sendEmail();
                        }
                        public synchronized void sendEmail() throws Exception{
                            System.out.println(Thread.currentThread().getName() + "\t ####invoked sendEmail");
                        }
```



​						4.递归锁:   递归锁就是可重入锁

​						5.自旋锁:	尝试去获取锁的线程不会立即阻塞,而是采用循环的方式去尝试获取该锁, 类似与CAS实现, 这样的好处是	

​                               减少线程上下文切换带来的消耗,缺点是循环会消耗cpu的性能

```java
                	// 原子引用
                    AtomicReference<Thread> atomicReference = new AtomicReference<>();

                    // 获取自旋锁
                    public void myLock(){
                        Thread thread = Thread.currentThread();
                        System.out.println(Thread.currentThread().getName() + "\t com in on ");
                        while(!atomicReference.compareAndSet(null, thread)) {
                        }
                    }
                    // 解锁
                    public void myUnlock(){
                        Thread thread = Thread.currentThread();
                        atomicReference.compareAndSet(thread, null);
                        System.out.println(Thread.currentThread().getName() + "\t myunlock run ..");
                    }
```

​                        6.独占锁(写锁): 指该锁一次只能被一个线程索持有, ReentrantLock和Synchronized都是独占锁

​						7.共享锁(读锁): 指该锁可被多个线程所持有

​								读可以共享, 写只能一个人写

​									写操作: 原子性 +  独占锁, 整个过程不允许被独占, 被打断

​						8.互斥锁:

```java
                    class MyCache{  // 资源类
                        private volatile Map<String, Object> map = new HashMap<>();
                        // 使用读写锁
                        private ReadWriteLock lock = new ReentrantReadWriteLock();
                    //    private Lock lock = new ReentrantLock();
                        public void put(String key, Object value) {
                            lock.writeLock().lock();
                            try {
                                System.out.println(Thread.currentThread().getName() + "\t 正在写入..." + key);
                                try {
                                    TimeUnit.MILLISECONDS.sleep(300);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                map.put(key, value);
                                System.out.println(Thread.currentThread().getName() + "\t 写入完成...");
                            } catch (Exception e) {
                                e.printStackTrace();
                            } finally {
                                lock.writeLock().unlock();
                            }
                        }
                        public void get(String key) {
                            lock.readLock().lock();
                            try {
                                System.out.println(Thread.currentThread().getName() + "\t 正在读取...");
                                try {
                                    TimeUnit.MILLISECONDS.sleep(300);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                Object result = map.get(key);
                                System.out.println(Thread.currentThread().getName() + "\t 读取完成..." + result);
                            } catch (Exception e) {
                                e.printStackTrace();
                            } finally {
                                lock.readLock().unlock();
                            }
                        }
                        public void cleanMap(){
                            map.clear();
                        }
                    }
```

#####       1.6 CountDownLatch:

​			 计数器:  等到countdownlatch 的数据减到0的时候,main线程才能执行

​						让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒

​								countdownLatch.countDown();  // 将计数器减一

​								countDownLatch.await();  // 调用程序被阻塞

```java
           		    CountDownLatch countDownLatch = new CountDownLatch(6);
                    for (int i = 1; i < 7; i++) {
                        new Thread(() -> {		
                            System.out.println(Thread.currentThread().getName() + "\t *********** 上完自习 离开教室");
                            countDownLatch.countDown();
                        },String.valueOf(i)).start();
                    }
                    countDownLatch.await();
                    System.out.println(Thread.currentThread().getName() + "\t ********** 班长走人关门");
```

#####       1.7 CyclicBarrier:

​				 case: 人到齐了才能开会

​				 字面意思是可循环使用的屏障, 他要做的事是让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会开门

​			小demo: 只有集齐7颗龙珠才能召唤龙哥

```java
                    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, new Thread(() -> {
                                System.out.println("召唤神龙");
                            }));
                            for (int i = 1; i <= 7; i++) {
                                final int tem = i;
                                new Thread(() -> {
                                    System.out.println(Thread.currentThread().getName() + "\t 收集到第" + tem +"颗灵珠");
                                    try {
                                        cyclicBarrier.await();
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    } catch (BrokenBarrierException e) {
                                        e.printStackTrace();
                                    }
                                }).start();
                            }
```

#####      1.8 Semaphore:

​			信号量:  同时访问的并发量

​			    目的: 一个是用于多个共享资源的互斥使用,另一个用于并发编程数的控制

```java
                Semaphore semaphore = new Semaphore(3); // 模拟三个停车位
                        for (int i = 1; i <= 6; i++) { // 模拟6个汽车
                            new Thread(() -> {
                                try {
                                    semaphore.acquire();  // 抢到车位
                                    System.out.println(Thread.currentThread().getName() +  "抢到车位");
                                    try {
                                        TimeUnit.MILLISECONDS.sleep(3);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    System.out.println(Thread.currentThread().getName() +  "停车三秒后离开车位");
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }finally {
                                    semaphore.release();  // 释放停车位
                                }
                            }, String.valueOf(i)).start();
                        }
```

#####     1.9 阻塞队列:

​				   当阻塞队列是空时,从队列获取元素的操作将会被阻塞

​				   当阻塞队列是满的时候,往队列里添加元素的操作将会被阻塞

​		   好处:   

​				  不需要我们关心什么时候需要阻塞线程,什么时候需要唤醒线程,BlockingQueue都做好了

​		    如何管理:

​		           1.ArrayBlockingQueue: 由数组结构组成的有界阻塞队

```java
          BlockingQueue<String> queue = new BlockingQueue(3);
		  queue.add("A");
          queue.add("B");
          queue.add("C");
		  queue.element();  // 检测队列第一个元素
		  // 加入第四个的时候会报队列已满的异常  java.lang.IllegalStateException: Queue full 
		  queue.remove();
          queue.remove();
          queue.remove();
          // 因为队列里面只有三个,当移除第四个的时候,会报 java.util.NoSuchElementException
			
			// 队列只有三个容量, 插入第四个返回false
			System.out.println(blockingQueue.offer("A"));
            System.out.println(blockingQueue.offer("B"));
            System.out.println(blockingQueue.offer("C"));
            System.out.println(blockingQueue.offer("D"));
			// 查看,但是并不取出
            System.out.println(blockingQueue.peek());
			// 取不到元素的时候返回false
            System.out.println(blockingQueue.poll());
            System.out.println(blockingQueue.poll());
            System.out.println(blockingQueue.poll());
            System.out.println(blockingQueue.poll());
					
					// 队列容量只有3个, 当加入第四个的时候,程序将被阻塞
			        blockingQueue.put("A");
                    blockingQueue.put("A");
                    blockingQueue.put("A");
                    System.out.println("============");
                    blockingQueue.put("A");
					// 当要取出第四个的时候,程序将会被阻塞
                    blockingQueue.take();
                    blockingQueue.take();
                    blockingQueue.take();
            //        blockingQueue.take();

			// 当添加元素时, 只会等待两秒钟,
			System.out.println(blockingQueue.offer("A", 2L, TimeUnit.SECONDS));
            System.out.println(blockingQueue.offer("B", 2L, TimeUnit.SECONDS));
            System.out.println(blockingQueue.offer("C", 2L, TimeUnit.SECONDS));
            System.out.println(blockingQueue.offer("D", 2L, TimeUnit.SECONDS));
```

​		2.LinkedBlockingQueue: 由链表组成的有界(但大小默认值Integer.MAX_VALUE)阻塞队列

​		3.PriorityBlockingQueue: 支持优先级排序的无界阻塞队列

​		4.DelayQueue: 使用优先级队列实现的延迟无界阻塞队列

​		5.SynchronousQueue: 不存储元素的阻塞队列,也即单个元素的队列   

```java
        		SynchronousQueue<String> queue = new SynchronousQueue<>();
                new Thread(() -> {
                    try {
                        System.out.println(Thread.currentThread().getName() + "\t put A");
                        queue.put("A");
                        System.out.println(Thread.currentThread().getName() + "\t put B");
                        queue.put("B");
                        System.out.println(Thread.currentThread().getName() + "\t put C");
                        queue.put("C");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }, "AAA").start();

                new Thread(() -> {
                    try {
                        try {
                            TimeUnit.SECONDS.sleep(3);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "\t" + queue.take());
                        try {
                            TimeUnit.SECONDS.sleep(3);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "\t" + queue.take());
                        try {
                            TimeUnit.SECONDS.sleep(3);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "\t" + queue.take());

                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                },"BBB").start();
```

​		6.LinkedTransferQueue: 由链表结构组成的无界阻塞队列

​		7.LinkedBlockingDeue: 由链表结构组成的双向阻塞队列   

​	用在哪里:

​			生产者消费者模式:

##### 1.10  synchronized和lock的区别:

​					1.synchronized是属于jvm层面,是java的关键字

​							monitorenter(底层是通过monitor对象完成的,其实wait和notify也是依赖monitor,只有在同步块或同步方法才能调用wait/notify)

​							monitorexit

​					    lock属于api层面,java1.5以后出现

​							是属于具体的类, 是java.util.concurrent包里面的

​                     2.使用方法的区别:

​								synchronized不需要手动释放锁

​								而lock需要手动释放锁

​					 3.等待是否可以中断

​								synchronized不可中断,除非抛出异常或者正常运行结束

​								Reentrantlock 可中断,  1.设置超时时间 tryLock(Long timeout, TimeUnit unit);

​																		 2.lockInterruptibly() 放代码块中,调用interrupt()方法可以中断

​					 4.加锁是否公平:

​									synchronized非公平锁

​									ReentrantLock 默认为非公平锁,构造方法可以传入boolean值,true为公平锁,默认为false

​					 5.锁绑定多个条件Condition

​									synchronized没有

​									ReentrantLock用来实现分组唤醒需要唤醒的线程们,可以精确唤醒,而不是像synchronized要么随机唤醒一个线程要么全部唤醒

​			一个ReentrantLock绑定多个Condition

```java
                private int num = 1; //  A:1   B:2   C:3
                    private Lock lock = new ReentrantLock();
                    private Condition condition1 = lock.newCondition();
                    private Condition condition2 = lock.newCondition();
                    private Condition condition3 = lock.newCondition();
                    public void printFive(){
                        lock.lock();
                        try {
                            // 1.判断
                            while (num != 1) {
                                condition1.await();
                            }
                            // 2.干活
                            for (int i = 1; i <= 5; i++) {
                                System.out.println(Thread.currentThread().getName() + "\t 执 行  " + i);
                            }
                            // 3.通知
                            num = 2;
                            condition2.signal();
                        } catch (Exception e) {
                            e.printStackTrace();
                        } finally {
                            lock.unlock();
                        }
                    }
                    public void printTen(){
                        lock.lock();
                        try {
                            // 1.判断
                            while (num != 2) {
                                condition2.await();
                            }
                            // 2.干活
                            for (int i = 1; i <= 10; i++) {
                                System.out.println(Thread.currentThread().getName() + "\t 执 行  " + i);
                            }
                            // 3.通知
                            num = 3;
                            condition3.signal();
                        } catch (Exception e) {
                            e.printStackTrace();
                        } finally {
                            lock.unlock();
                        }
                    }
                    public void printFiveTeen(){
                        lock.lock();
                        try {
                            // 1.判断
                            while (num != 3) {
                                condition3.await();
                            }
                            // 2.干活
                            for (int i = 1; i <= 15; i++) {
                                System.out.println(Thread.currentThread().getName() + "\t 执 行  " + i);
                            }
                            // 3.通知
                            num = 1;
                            condition1.signal();
                        } catch (Exception e) {
                            e.printStackTrace();
                        } finally {
                            lock.unlock();
                        }
                    }
```

​			 阻塞队列版的生产者消费者模型:

```java
            	private volatile Boolean flag = true;  // 标志位, 控制程序的运行和停止
                private AtomicInteger atomicInteger = new AtomicInteger(1);  // 共享数据
                BlockingQueue<String> blockingQueue;
                public MySour(BlockingQueue<String> blockingQueue) {
                    this.blockingQueue = blockingQueue;
                }
                public void myPro() throws Exception{

                    String result = null;
                    boolean reVal = false;
                    while (flag) {

                        result = atomicInteger.getAndIncrement()+"";
                        reVal = blockingQueue.offer(result, 2L, TimeUnit.SECONDS);
                        if (reVal) {
                            System.out.println(Thread.currentThread().getName() + " 生产者插入" + result + "成功");
                        }else {
                            System.out.println(Thread.currentThread().getName() + " 生产者插入" + result + "失败");
                        }
                        TimeUnit.SECONDS.sleep(1);
                    }
                    System.out.println(Thread.currentThread().getName() + " 生产者结束生产");
                }

                public void myConsum() throws Exception {

                    String result = null;
                    while (flag) {
                        result = blockingQueue.poll(2, TimeUnit.SECONDS);
                        if (result == null || result.equalsIgnoreCase("")) {
                            System.out.println(Thread.currentThread().getName() + "超过两秒, 消费者不消费了");
                            System.out.println();
                            System.out.println();
                            return;
                        }else {
                            System.out.println(Thread.currentThread().getName() + "消费者取出" +result + "商品");
                        }
                    }
                    System.out.println("main线程叫停,消费者退出");
                }

                public void stop(){
                    System.out.println("main线程叫停");
                    this.flag = false;
                }

```

##### 1.11 Callable:

​			为啥有了Runable接口还要设计Callable:

```java
 		FutureTask<Integer> futureTask = new FutureTask<>(new MyThread()); // myThread 实现了Callable接口
        new Thread(futureTask, "AAA").start();
```

##### 1.12 线程池:

​	        优势: 线程复用,控制最大并发数,更好的管理线程

​					1.降低资源消耗,通过重复利用已创建的线程降低线程创建和销毁造成的消耗

​				    2.提高响应速度,当任务达到时,任务可以不需要的等到线程创建就能立即执行

​					3.提高线程的可管理性

​		

```java
                        Executors.newFixedThreadPool(5);  // 创建固定数量的线程池  执行长期的任务,性能好很多
                        Executors.newSingleThreadExecutor(); // 创建单个线程池     一个任务一个任务执行的场景
                        Executors.newCachedThreadPool();  // 创建可扩容的线程池    执行很多短期异步的小程序或者负载较轻的服务器
					
                public static ExecutorService newFixedThreadPool(int nThreads) {
                    return new ThreadPoolExecutor(nThreads, nThreads,
                                             //创建线程的数量   //  
                                                  0L, TimeUnit.MILLISECONDS,
                                                  new LinkedBlockingQueue<Runnable>());
                }	

			
                public static ExecutorService newSingleThreadExecutor() {
                        return new FinalizableDelegatedExecutorService
                            (new ThreadPoolExecutor(1, 1,
                                                    0L, TimeUnit.MILLISECONDS,
                                                    new LinkedBlockingQueue<Runnable>()));
                    

                public static ExecutorService newCachedThreadPool() {
                    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                                  60L, TimeUnit.SECONDS,
                                                  new SynchronousQueue<Runnable>());
                    
                    
                    public ThreadPoolExecutor(int corePoolSize,
                                                  int maximumPoolSize,
                                                  long keepAliveTime,
                                                  TimeUnit unit,
                                                  BlockingQueue<Runnable> workQueue) {
                            this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                                 Executors.defaultThreadFactory(), defaultHandler);
                        }

												     // 常驻核心线程数(初始化的个数),理解为今日值班线程
                    							// 当线程池中的线程数达到corepoolsize的时候,会把到达的任务放到缓存队列中
                         public ThreadPoolExecutor(int corePoolSize,
                                                      // 线程池的最大线程数, 必须大于等于1
                                                      int maximumPoolSize,
                                                   	  // 当当前线程池的线程总数的keepAliveTime(unit单位)时间内都超过corePoolSize时,
                                                   	  // 就会将多余的线程销毁直至剩下corePoolSize为止
                                                      long keepAliveTime,
                                                      TimeUnit unit,
                                                   	  // 阻塞队列,当常驻核心线程使用完的时候,会把任务放到阻塞队列中
                                                      BlockingQueue<Runnable> workQueue,
                                                   	  // 生成线程池中工作线程的线程工厂,一般用默认即可
                                                      ThreadFactory threadFactory,
                                                   	  // 线程池的拒绝策略
                                                      RejectedExecutionHandler handler) {

						
```

######      1.12.1线程池底层工作原理:

​					1.线程池在初始化的时候会创建corepoolsize个线程

​					2.当提交的任务小于corepoolsize的时候,不用新创建线程

​					3.当提交的任务大于了corepoolsize的,进入阻塞队列中workqueue中

​					4.当提交的任务阻塞队列也放不下的时候,且正在运行的线程数还小于maximumPoolSize时,会创建新的非核心线程运行这个任务

​							4.1 如果正在运行的线程数大于了maximumPoolSize,那么线程池会开启拒绝策略

​					5.当一个线程无事可做超过keepAliveTime(单位为unit)时,线程池会判断当前运行的线程数大于maximumPoolSize,这个线程就会被停掉

​							当线程池的所有任务完成时最终会收缩到corepoolsize的大小

######     1.12.2 线程池的拒绝策略:

​					1.AbortPolicy(默认): 直接抛出 RejectedExecutionException异常阻止系统正常运行(java.util.concurrent.RejectedExecutionException)

​		            2.CallerRunsPolicy: "调用者运行"一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是会将某一些任务回退给调用者

​									// 处理不了的任务,哪个线程调用的我,就回退给谁

​					3.DiscardOldestPolicy: 抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交当前任务

​								   // 能处理完就处理完,处理不完直接丢弃

​					4.DiscardPolicy: 直接丢弃任务,不予任何处理也不抛出异常,如果允许任务丢失,这是最好的一种方案

​								  //  超过最大线程数maximumPoolSize + 阻塞队列的个数,直接丢弃

######    1.12.3使用哪一个拒绝策略:

​				 	1.newFixedThreadPool 和 newSingleThreadExecutor:

​							允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量请求,从未导致oom

​					 2.newCachedThreadPool 和 ScheduledThreadPool:

​							允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量请求,从未导致oom

######    1.12.4 如何配置线程池的参数:

​					根据业务设定:

​							corePoolSize 一般设为0或者1

​							根据Runtime.getRuntime().availableProcessors()得到cpu核数 

​									1.cpu密集型(不停的执行任务):

​												maximumPoolSize= cpu核数 + 1 

​									2.IO密集型(大量的阻塞): 		

​												2.1由于IO密集型任务线程并不是一直执行任务,则应配置尽可能多的线程:

​														maximumPoolSize = cpu * 2 			

​                                                2.2单线程运行IO密集型的任务会导致大量的cpu运算能力浪费在等待

​														公式: CPU核数/(1-阻塞队列)   阻塞系数在0.8~0.9

​                                                         例如8核cpu:  maximumPoolSize  =  8 / (1-0.8)  = 40

##### 1.13 死锁编码及定位分析:

​				  死锁是两个或两个以上的进程在执行过程中.因争夺资源而造成的一种互相等待的现象

```java
public class DeadSync {

    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new HoldLock(lockA, lockB), "threadAAA").start();
        new Thread(new HoldLock(lockB, lockA), "threadBBB").start();
    }
}

class HoldLock implements Runnable{
    
    private String lockA;
    private String lockB;
    
    public HoldLock(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }
    
    @Override
    public void run(){
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName() + "\t 自己持有" + lockA + "\t 尝试获取别人的" + lockB);
            try {
                TimeUnit.MILLISECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName() + "\t 自己持有" + lockB + "\t 尝试获取别人的" + lockA);
            }
        }
    }
}

```



​                jvm命令:

​						jsp:        linux    ps -ef | grep xxx

​										windows 下的java程序   也有类似的查看进程的命令

​				                        jps  -l		

​										jstack   xxx进程编号			

![image-20200306101232364](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20200306101232364.png)	    

![image-20200306101153133](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20200306101153133.png)

#### 2.jvm

​		    计数算法: 对象有一个引用,计数 + 1

​		    复制算法(复制 -> 清空 -> 互换):   

​		    标记清除:  没有大部分的去复制,节约了空间, 缺点是产生了内存碎片

​			标记清除整理: 标记 -> 压缩: 再次扫描,把存活对象整理到一端 , 再去清除   缺点是移动成本高

​			 分代收集算法:

######    2.1 GC Roots:

​				2.1.1 如何确定垃圾: 

​								简单来说就是内存中已经不再被使用到空间的就是垃圾

​				2.1.2 如何判断:   

​								引用计数法: 每一个地方引用,就加1,每个地方的引用失效,就 -1 ,但是很难解决循环引用的问题

​							    枚举根节点做可达性分析:

​										 通过一系列名为GC Roots的对象作为起点,进行可达性分析

​										1)  从这个GC roots 集合的对象开始向下进行搜索,如果一个对象到GC root 没有任何引用链相连时,则说明此对象不可用

  									   2)  否则,就算几个对象内部引用了,也算为不可达

​                2.1.3  哪些对象可以成为gc root

​							 1.虚拟机栈中引用的对象

​							 2.方法区中的类静态属性引用的对象

​							 3.方法区中常量引用的对象

​							 4.本地方法中native引用的对象  	

######  2.2 jvm 调优:

​				2.2.1 jvm参数类型:

​						1.标配参数:  -version  ,  -help,  java -showversion

​						2.X参数:  -Xint  解释执行 ,   -Xcomp 第一次使用就编译为本地代码 ,  -Xmixed  混合模式

​						3.XX参数: 

​								 3.1 Boolean类型: -XX: + 或者 - 某个属性   + 表示开启   - 表示关闭

​											jps -l  查看进程号  

​											jinfo -flag PrintGCDetails 4244   查看PrintGCDetails 参数是否开启

​											jinfo -flags 进程编号   查询所有

​								 3.2 KV设值类型:  -XX:属性key=属性值value

​												-XX:MetaspaceSize=128m  // 元空间大小

​												-XX:MaxTenuringThreshold=15   //  对象活过15次之后才能到老年代

​							-Xms: 初始的堆空间    ==  -XX:InitailHeapSize

​							-Xmx: 堆空间的最大值  ==  -XX:MaxHeapSize

​							-Xss:  初始的栈空间   ==   -XX:ThreadStackSize

​                2.2.2 查看jvm默认值:

​								 1. -XX:+PrintFlagsInitial   // jvm初始化参数

​								 2. -XX:+PrintFlagsFinal   // 查看修改和更新的内容

​								 3. -XX:+PrintCommandLineFlags   // 查看默认的垃圾回收器

​				 2.2.3 

```java
        long totalMemory = Runtime.getRuntime().totalMemory();  // 返回虚拟机的内存总量
        long maxMemory = Runtime.getRuntime().maxMemory();   // 虚拟机使用的最大容量
```

​                  2.2.4  常用调优参数:

```java
                  1. -Xms 初始的堆内存 默认物理内存的1/64    -XX:InitailHeapSize   
                  2. -Xmx   最大的堆内存  默认物理内存的1/4  -XX:MaxHeapSize
                  3. -Xss 单个线程栈的大小                  -XX:ThreadStackSize 
                  https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html  // 官网
                  4. -Xmn  设置年轻代大小
                  5. -XX:MetaspaceSize 设置元空间大小 // 默认20m
                  6. -XX:+PrintGCDetails  // 收集GC详细日志情况
                  7. -XX:SurvivorRatio // 调整eden survivor1区  survivor2区的比列(默认8:1:1)
                      	 
                  8. -XX:NewRatio     // 设置新生代和老年代的比列 
                      			// 比如: -XX:NewRatio=4  新生代 1  老年代 4  年轻代占整个堆的1/5
                  9. -XX:MaxTenuringThreshold //  设置垃圾最大年龄   
```

 ```java
     -Xms10m -Xmx10m -XX:+PrintGCDetails  // 命令行加入  // 收集GC详细日志情况
                  
      // GC类型      //  收集失败  新生代   //GC前新生代内存占用:1920K   // 1920K GC前堆内存的占用  696K GC后堆内存的占用
      [GC (Allocation Failure) [PSYoungGen: 1920K->488K(2560K)] 1920K->696K(9728K), 0.0256731 secs]
                      					//488K GC后新生代内存占用       //  堆的总空间
                      					//2560K 新生代的占用大小
 ```

```java
                             //新生代    // 收集前           //老年代                             //堆的总内存   //元空间
[Full GC (Allocation Failure) [PSYoungGen: 504K->0K(2560K)] [ParOldGen: 208K->631K(7168K)] 712K->631K(9728K), [Metaspace: 3478K->3478K(1056768K)], 0.0079455 secs]                                                                          
                     // 消耗时间
```



```java
-XX:+PrintGCDetails -XX:+UseSerialGC -Xms10m -Xmx10m -XX:SurvivorRatio=4
    												     设置eden区和survivo1和survivor2区的比列
    															4       1         1
```

######             2.3  强,弱,软虚引用:

​							java.lang.ref包下

​							 

​					          2.3.1 Reference(强引用): 把一个对象赋给一个引用变量,这个引用变量就是强引用(就算OOm都不会回收)

​							  2.3.2 SoftReference(软引用):   内存够的情况下,不会收,内存不够了,就会回收

​							  2.3.3 WeakReference(弱引用):  只要触发垃圾回收,不管内存 够不够用.都要回收 

​									应用场景: 有一个应用需要读取大量本地图片, 如果每次从硬盘读会影响性能,如果一次性全部加载到内存又可能造成内存溢出

​												    这个时候可以使用软引用

```java
                        Object o = new Object();
                        WeakReference<Object> weakReference = new WeakReference<>(o);
                        System.out.println(o);
                        System.out.println(weakReference);
                        o = null;
                        System.gc();
                        System.out.println(o);
                        System.out.println(weakReference.get());					  		 
```

​							2.3.4 PhantomReference(虚引用):  如果一个对象仅持有虚引用,和没有引用一样,在任何时候都有可能被回收

​												在被回收的之前,会被加入引用队列

```java
                            Object o = new Object();
                            ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
                            PhantomReference<Object> phantomReference = new PhantomReference<>(o, referenceQueue);

                            System.out.println(o);
                            System.out.println(phantomReference);
                            System.out.println(referenceQueue);

                            System.out.println("=====================");
                            o = null;
                            System.gc();
                            Thread.sleep(1);

                            System.out.println(o);
                            System.out.println(phantomReference.get());
                            System.out.println(referenceQueue.poll());
```

​																	   	 

​						    2.3.5 ReferenceQueue:   当对象被回收的时候,会放到引用队列里面

```java
                        Object o = new Object();
                        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
                        WeakReference<Object> weakReference = new WeakReference<>(o,referenceQueue);

                        System.out.println(o);
                        System.out.println(weakReference.get());
                        System.out.println(referenceQueue.poll());
                        System.out.println("===============");

                        o = null;
                        System.gc();
                        try {
                            TimeUnit.MILLISECONDS.sleep(1);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(o);
                        System.out.println(weakReference.get());
                        System.out.println(referenceQueue.poll());
```



######     2.4 WeakHashMap:

```java
                WeakHashMap<Integer, String> Map = new WeakHashMap();
                Integer key = new Integer(1);
                String value = "WeakHashMap";
                Map.put(key, value);
                System.out.println(Map);
                key = null;
                System.out.println(Map);
                System.gc();
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Map.size() +" " +Map);
```

​                      是一种弱引用, 当gc时,会被回收



###### 2.5 SOFE

​			 Stack over flow error: 

​			 out of memory error : java heap space

​			 out of  memory error: GC overhead limit exceeded  // 超过80%的时间程序用来做垃圾回收,但是回收效果不明显,只回收了2%的堆内存,所以爆出了这个异常

​						//  -Xms10m  -Xmx10m -XX:+PrintGCDetails

```java
                		int i = 0;
                        List<String> list = new ArrayList<>();
                        try{
                        while (true) {
                            list.add(String.valueOf(++i).intern());
                        }
                        }catch (Throwable e) {
                            System.out.println("*******"  + i);
                            e.printStackTrace();
                            throw e;
                        }
```

​			 out of memory error: Direct buffer memory  // 直接内存挂了  

​						//   直接分配本地内存, 不属于jvm管辖范围内,如果本地内存使用光了的话,再次尝试分配本地内存的话,就会出现oom异常

```java
                    System.out.println(VM.maxDirectMemory()/ 1024 / 1024);
                    try{
                        Thread.sleep(3000);
                    }catch (Exception e){
                        e.printStackTrace();
                    }
                    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024);
```

​			 out of memory error: unable to create new write native thread  // 高并发请求服务器时,出现此异常

```java
应用创建的线程太多了,一个应用进程创建多个线程,超过系统承载极限
你的服务器并不允许你的应用创建这么多的线程(linux单个进程最多可以创建1024个线程)    
    								   修改非root用户最大线程数: vim /etv/security/limit.d
    
```



​			 out of memory error: Metaspace	

​				// 不停的往元空间放类模板信息, 就会报Metaspace异常

​				-XX:MetaspaceSize=5m -XX:MaxMetaspaceSize=5m

```java
            static class Test{

                }

                public static void main(String[] args) {
                    int i = 0;
                    try {
                        while (true) {
                            Enhancer enhancer = new Enhancer();
                            enhancer.setSuperclass(Test.class);
                            enhancer.setUseCache(false);
                            enhancer.setCallback(new MethodInterceptor() {
                                @Override
                                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws 								Throwable {
                                    return methodProxy.invokeSuper(o, args);
                                }
                            });
                            enhancer.create();
                        }
                    } catch (Exception e) {
                        System.out.println("*********" + i);
                        e.printStackTrace();
                    }
                }
```

######   2.6 垃圾收集器:

​			2.6.1  垃圾回收算法: 引用计数, 复制拷贝, 标记清除,标记整理:

​					GC算法是内存回收的方法论, 垃圾收集器就是算法的落地实现

​					 2.6.1:   Serial 串行回收     他为单线程环境设计,且只使用一个线程进行垃圾回收,会暂停所有的用户线程,不适合服务器环境

​					 2.6.2:   Parallel 并行回收  多个垃圾回收收集器线程并行工作,此时用户线程是暂停的,适用于科学计算或大数据处理首台处理等弱交互场景

​					 2.6.3:   CMS  并发标记清除  用户线程和垃圾回收线程同时执行(不一定是并行,可能是交替执行),不需要停顿用户线程

​					 3.6.4:    G1(global first)   将堆内存分割成不同的区域然后并发的进行垃圾回收

​           2.6.2   怎么查看默认的垃圾收集器:  

​		             java -XX:+PrintCommandLineFlags -version

​					 -XX:+UseParallelGC   java8 默认使用并行的垃圾收集器

```
java默认的垃圾收集器: 
						UseSeri  
						alGC,   UseParallelGC, UseConcMarkSweepGC(并发标记清除)CMS   Concurrent(并发)Mark(标记)Sweep(清除)
						UseParallelNewGC(年轻代),  UseParallelOldGC(老年代),  UseG1GC
```

​			    如何查看L   jps -l  查看进程编号

​									jinfo -flag UseSerialGC java进程编号	

​			2.6.3  垃圾收集器:

​								 Young Gen:  Serial Copying(串行)   Parallel Scaverge(并行)  ParallelNew(新生区)

​								  Old Gen:      Serial MSC(Serial Old)    Parallel Compacting(Parallel Old)     CMS (并发标记清除)   

​								       G1 :          都可以收集年轻代和老年代

​           2.6.4  约定参数说明:

​								  DefNew:   新生代用的哪个垃圾收集器

​							      Tenured   Old

​								  ParNew     新生代用并行回收

​								  PSYoungGen   年轻代用并行

​                                  ParOldGen     老年代 用 并行

​			2.6.5  

​							新生代:   1. Serial串行   对应jvm参数: -XX:+UseSerialGC

​							                           Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC

​												        开启后会使用: Serial + SerialOld 的组合

​												        新生代用复制算法,  老年代用标记整理算法

​                                          2.  ParaNew 并行     新生代用 并行   老年代用Serial Old  使用标记整理	

​													jvm参数:  -XX:+UseParNewGC			-XX:ParallelGcThreads  限制开启几个线程区垃圾回收    默认开启cpiu核数个线程 		

​										  3. Parallel并行回收:  串行收集器在新生代和老年代的并行化   

​															jvm参数:  -XX:+UseParallelGC   /  -XX:UseParallelOldGC

​												既然有ParNew 为什么要有 Parallel呢:		

​																	 1. 可控制的吞吐量:	Thoughput = 运行用户代码时间/(运行用户代码时间+垃圾收集时间) 

​																	 2.  自适应调节策略    -XX:MaxGCPauseMillis 最合适的停顿时间

​																	 3.  -XX:ParallelGcThreads  设置线程

​							老年代: 

​										 1.ParallelOld/ Parallel    

​										 2.SerialOld/Serial MSC   标记整理算法

​								         3.并发标记清除GC(CMS):  

​															jvm参数:  -XX:+UseConcMarkSweepGC   自动开启  -XX:+UseParNewGC

​                                                          使用ParNew  + CMS + SerialOld 收集器

​															SerialOld作为CMS出错的备用收集器

​				                                                    4步过程:

​																			1.初始标记(CMS initial Mark)  标记GC roots 可以直达的对象   stop

​																			2.并发标记(CMS concurrent Mark) 和用户线程一起执行  从第一步标记对象开启,进一步标记可达对象

​																			3.重新标记(CMS remark)   二次确认垃圾   stop

​																			4.并发清除(CMS concurrent sweep)  和用户线程一起

​												    优点:  并发收集低停顿

​													缺点:   并发执行,对cpu资源压力大

​																			CMS必须要在老年代堆内存耗尽之前完成垃圾回收,否则收集失败, 启用备用GC

​																             采用标记清除会导致大量内存碎片

​																					通过-XX:CMSFullGCsBeForeCompaction来指定多少次CMS收集之后进行一次压缩的FullGC				

​                    2.6.6  如何选择垃圾收集器:

​										1.单cpu或者单机程序: SerialGC    

​										2.多cpu,需要最大吞吐量,如后台计算型应用

​													ParallelGC + ParallelOldGC

​                                         3.多cpu, 低停顿时间, 需要快速响应

​													ConcMarkSweepGC + ParNew  + SerialOld(备份)

​					 2.6.7 收集器使用的算法:

| 参数                                     | 新生代垃圾收集器   | 新生代算法                          | 老年代垃圾收集器           | 老年代算法 |
| ---------------------------------------- | ------------------ | ----------------------------------- | -------------------------- | ---------- |
| -XX:+UseSerialGC                         | SerialGC           | 复制                                | SerialOldGC                | 标记整理   |
| -XX:+UseParNewGC                         | ParNewGC           | 复制                                | SerialOldGC                | 标记整理   |
| -XX:+UseParallelGC/-XX:+UseParallelOldGC | ParallelGC         | 复制                                | ParallelOldGC              | 标记整理   |
| -XX:+UseConcMarkSweepGC                  | CMSGC              | 复制                                | ParNewGC + SerialOld(备用) | 标记清除   |
| -XX:+UseG1GC                             | G1整体上标记整理法 | 局部是通过复制算法,不会产生内存碎片 |                            |            |

​                  2.6.8 G1垃圾收集器:

​								开启: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseG1GC

​								 是一款面向服务端应用的收集器:

​								        G1是一个由整理过程的垃圾收集器,不会产生很多内存碎片

​										G1的Stop The World(STW) 更可控, G1在停顿时间上添加了预测机制,用户可以指定期望停顿值

​								        主要改变是Eden Survivor1 Survivor2 和 Tenured等内存区域不再是连续的,变成了一个个region

​                                         整体上采用标记整体,局部采用复制

​										 G1 只有逻辑上的分代概念,或者说每个分区都可能随着G1运行在不同代不断切换

​                            G1底层原理:

​										 通过-XX:G1HeapRegionSize=n,可指定分区大小(1-32mb,且必须为2的幂) 	

​               									1.初始标记   只标记Gc roots能直接关联到的点

​												   2.并发标记   进行GC roots Tracing的过程

​												   3.最终标记   修正并发标记期间,因程序运行导致标记发生变化的那一部分对象

​												   4.筛选回收    根据时间来进行价值最大化的回收			

​                              常用参数配置:

​											-XX:+UseG1GC  

​											-XX:G1HeapRegionSIze=n   设置G1的区域大小

​											-XX:MaxGCPauseMillis=n   最大GC停顿时间(GC线程运行时间)  软配置

​											-XX:InitiatingHeapOccupancyPercent=n   堆占用多少内存会触发GC  默认45

  										  -XX:ConcGCThreads=n     并发GC使用的线程数

​											-XX:G1ReservePercent=n   设置作为空闲空间的预留内存百分比, 以降低目标空间溢出的风险

​							 G1和CMS的区别:

​											1.G1标记整理 不会产生内存碎片  CMS会

​											2.G1可以精确的控制停顿

###### 2.7 JVMGC + SpringBoot 微服务的生产部署和调参优化

​						1.maven进行clean package	

​						2.要求微服务启动的时候,同时配置jvm/GC的调优参数

​								2.1 idea内部配置

​								2.2  外部命令行

​						3.java -server  jvm的参数 -jar   xxxxx.jar

​										java -server -Xms1024m -Xmx1024m -XX:+UseG1GC  -jar   XXXX.jar

#### 3.linux

##### 		3.1 常用命令:

###### 					3.1.1  整机:  top / uptime 精简版

​												load average:  0.80(1分钟系统负载)  0.53(5分钟系统负载)  0.21(15分钟系统负载)

​																          三个相加 / 3   * 100%  超过60%  说明系统压力过大

![image-20200307151257134](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20200307151257134.png)

###### 					3.1.2 cpu: vmstat

​						 	mpstat -P ALL 2   // 查看所有cpu核信息

​							pidstat -u 1 -p 进程编号   // 每个进程使用cpu的用量分解信息

​									 vmstat -n 2 3    // 每两秒采样一次,共3次

![image-20200307152215004](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20200307152215004.png)

```java
procs:  r(runtime) 运行和等待cpu时间片的进程数,原则上1核cpu不超过2,整个系统的运行队列不能超过总核数的2倍
    	b(阻塞)  等待磁盘的进程数
cpu:    us(用户) 用户进程消耗cpu时间百分比
    	sy(系统)    如果us + sy  大于80%  说明可能存在cpu不足
```

###### 					3.1.3 内存: free   查看内存		

```java
free -m  // 单位是mb
free -g  // 单位gb  
pidstat -p 进程号 -r 采样间隔秒数    
```

###### 					3.1.4  硬盘: df(destfree)

```java
df -h  // 用人类的方式去看
```

###### 					3.1.5 磁盘IO:  iostat

```java
iostat -xdk 2 3
		rkB/s    每秒读取数据量kb
    	wkB/s    每秒写入数据量kB
    	svctm    I/O请求的平均服务时间,单位毫秒
    	await    I/O请求的平均等待时间,单位毫秒,值越小,性能越好
    	util     **** 一秒有百分之几的时间用于IO操作,接近100%时,表示磁盘带宽跑满,需要优化程序或者增加磁盘
    	rkB/s wkB/s  根据系统应用不同会有不同的值,但有规律遵循,长期 超大数据读写,肯定不正常,需要优化程序读取
    	  svctm的值与await的值很接近 ,表示几乎没有IO等待,磁盘性能很好
    	  如果await的值远高于svctm的值,则表示IO队列等待太长,需要优化程序或者更换磁盘	
```

![image-20200307154642666](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20200307154642666.png)

###### 3.1.6  网络IO: ifstat



##### 3.2  cpu占用过高, 思路定位	

​			 结合linux 和 jdk命令一块分析:

​						1.先用top命令找到cpu占用过高的

​						2.ps -ef | grep xxx 或者 jps -l  进一步定位

​						3.定位到具体的线程或者代码							

```
ps -mp 进程编号 -o THREAD,tid,time
		  -m  显示所有的线程
		  -p  pid进程使用cpu的时间
		  -o  该参数后是用户自定义格式
```

​						4.将需要的线程Id转换为16进制格式(英文小写格式)

```java
printf "%x\n" 有问题的线程id
```

​						5.jstack 进程编号| grep tid(16进制线程id小写英文)  -A60

#### 4.gitHub

###### 			4.1 如何找到优秀的源码 + 进行深度的框架解读 + 学习其他高手的代码 + 自己共享

​					watch: 会持续收到该项目的动态

​					fork:  复制某个项目到自己的github仓库中

​					star:  点赞

​					clone: 将项目下载到本地

​					follow: 关注你感兴趣的作者,会收到他们的动态

###### 			4.2 in关键词操作:

​					xxx关键词   in:name 或者description或readme

​							seckill in:name,readme

​							seckill in:name,readme,description

###### 			4.3 stars 查询:					

​							公式:     xxx关键字 stars  通配符  :>   :>=

​										  区间范围数字          数字1..数字2

​							例子:   springboot stars:>=5000

###### 			4.4 forks查询:	

​							springcloud forks:>=500	

###### 			4.5 组合使用:

​							查找forks在100到200之间并且stars在80到100之间的springboot项目

​							springboot stars:80..100 forks:100..200

###### 			4.6 awesome 加强搜索

​							awesome   关键字xxx      学习用

###### 			4.7  高亮显示某一行代码:

​							给别人指出关键代码的行号

​							地址 + #L行号 + -L行号

​							https://github.com/codingXiaxw/seckill/blob/master/src/main/java/cn/codingxiaxw/dao/SeckillDao.java#L13-L23

###### 			4.8  项目内搜索:

​							鼠标放到页面按t

###### 			4.9  搜索某个地区的大佬:

​							location:地区

​							language:语言

​									location:xian language:java